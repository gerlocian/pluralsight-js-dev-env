The development starter kit checklist

1) Editor
    a) Options:
        1) Atom
        2) Webstorm
        3) Brackets
        4) VSCode
    b) Look for
        1) Strong ES2015+ support
            a) Autocompletion
            b) Parse ES6 imports
            c) Report unused imports
            d) Automated refactoring
        2) Framework intelligence
        3) Built in terminal
    c) Editorconfig
        1) .editorconfig in the root of the project.
        2) http://editorconfig.org/

2) Package management
    a) Options
        1) NPM - Most popular
        2) Bower
        3) JSPM - also a bundler (see bundlers)
        4) Jam
        5) Volo
    b) Package security
        1) Options
            a) retire.js
            b) Node Security Platform
        2) When to test
            a) Manually - Easy to forget
            b) npm install - May have issues later after the install
            c) production build time - expensive change later
            d) pull request - expensive change later
            e) npm start - slightly slow to start the service

3) Development web server
    a) Options
        1) http-server
            a) ultra simple
            b) single command serves current directory
            c) amazing logo
        2) live-server
            a) lightweight
            b) supports live-reloading
        3) express
            a) comprehensive
            b) highly configurable
            c) production grade
            d) can run it anywhere
            e) koa and hapi are other alternative server options for this space
        4) budo
            a) integrates with Browserify
            b) includes hot reloading - immediately see changes
        5) webpack dev server
            a) built in to webpack
            b) serves from memory
            c) includes hot reloading
        6) browsersync
            a) dedicated IP for sharing work on LAN
            b) all interactions remain in sync
            c) great for cross device testing
            d) integrates with webpack, browserify, express and gulp
    b) with the exception of express, these servers are not production ready.
    c) sharing work-in-progress
        1) Options
            a) localtunnel
                1) lowest friction
                2) easily share work on local machine
                3) npm install localtunnel -g
                4) start you app
                5) lt --port <port> --subdomain <subdomain>
                6) port is the port of the running service
                7) subdomain is the subdomain i would like it to use
            b) ngrok
                1) popular
                2) signup
                3) install ngrok
                4) install authtoken
                5) start your app
                6) ./ngrok http 80
            c) surge
                1) quickly host static files to public url (only static)
                2) extreme simplicity
                3) npm install -g surge
                4) command: surge
            d) now
                1) quickly deploy node.js to the cloud
                2) production ready
                3) npm install -g now
                4) create start script
                5) command: now
                6) more permanent solution

4) Automation
    a) Options:
        1) Grunt
            a) The "original"
            b) configuration over code
            c) writes intermediary files between steps
            d) large plugin ecosystem
        2) Gulp
            a) in-memory streams (pipes)
            b) fast
            c) code over configuration
            d) large plugin ecosystem
        3) NPM Scripts
            a) declared in package.json
            b) leverage your OS' command line
            c) directly use npm packages
            d) call separate node scripts
            e) convention-based pre/post hooks
            f) leverage world's largest package manager
    b) Why NPM Scripts?
        1) Use tools directly
        2) No need for separate plugins
        3) simpler debugging
        4) better documentation
        5) easy to learn
        6) simple
        7) bit.ly/npmvsgulp
        8) By convention, if you append "pre" or "post" to a script name, npm scripts will run those before or after
            the script. For example:
            "prestart": "echo 'Does something before start'",
            "start": "echo 'Does start command'",
            "poststart": "echo 'Does something after start'"

5) Transpiling
    a) Options
        1) https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS
        2) Babel
            a) Modern, standards-based JS, today.
            b) Write standardized JS
            c) Leverage full JS ecosystem
            d) Use experimental features earlier.
            e) Quicker support for stage 0 features
            f) No type definitions, annotations required.
            g) ES6 imports are statically analyzable
            h) Test, lint, babel, great libs, IDE = safety
        3) TypeScript
            a) Superset of JavaScript.
            b) Enhanced autocompletion.
            c) Enhanced readability.
            d) Safer Refactoring
            e) Clearer intent
            f) Additional non-standard features.
        4) Elm
            a) Compiles down to JS
            b) Clean syntax
            c) Immutable data structures.
            d) Friendly errors
            e) Compile is assistive
            f) All errors are compile time errors
            g) Interops with JS
            h) Learning curve when shifting to elm
        5) There is no wrong answer, just different options.

6) Bundling
    a) Module format
        1) IIFE
        2) Asynchronous Module Definition (AMD)
        3) CommonJS (CJS) -- Recommended
        4) Universal Module Definition (UMD)
        5) ES6 Modules -- Highly recommended
    b) Why ES6 Modules?
        1) Standardized - future
        2) Statically analyzable - Read and analyzed predictably
            a) Improved autocompletion
            b) Intelligent refactoring
            c) Fails fast - find out bad issues sooner
            d) Tree shaking - dead code elimination
        3) Easy to read
            a) Named imports
            b) Default exports
    c) Selecting a bundler
        1) Options
            a) browserify - simple
                1) The original - first bundler to reach mass adoption
                2) Bundle npm packages for the web
                3) Large plugin ecosystem
            b) webpack - comprehensive
                1) Bundles more than just JS
                2) Import CSS, images, etc like JS
                3) built in hot-reloading web server
                4) strategic bundle splitting
                    a) separate bundles for different areas of the app
                5) hot module reloading
                6) Webpack2 offers tree shaking
                7) Large adoption
            c) rollup - tree shaking, performance
                1) Tree shaking
                2) Faster loading production code - all code in the same scope
                3) Con: Quite new - fewer libraries at this point
                4) Great for library authors
                5) No hot reloading and code splitting yet.
            d) jspm - runtime loader, package manager
                1) Uses SystemJS, a universal module loader
                2) Can load modules at run time
                3) Has it's own package manager
                4) Can install from NPM, git, etc
                5) uses rollup
        2) Debugging
            a) Sourcemaps
                1) Maps code back to the original source
                2) Part of our build
                3) Downloaded only if you open developer tools

7) Linting
8) Testing and continuous integration
9) HTTP requests
10) Project structure
11) Production build
12) Production deployment
13) Keeping it updated
